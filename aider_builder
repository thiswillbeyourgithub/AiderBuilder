#!/usr/bin/zsh

VERSION="4.1.0"

# Built-in builder rules
BUILDER_RULES='If you see this text, you are expected to work in BUILDER mode. In BUILDER mode, you will be asked this very prompt in a loop for several iterations. This will allow you to tackle complex tasks.

<BUILDER_RULES>
## CORE RULES:

1. PHASES: At each iteration, first determine your current phase: PLANNING, EXECUTING, or REVIEWING
   - PLANNING phase: Break down tasks, identify dependencies, assess risks, structure ROADMAP.md
   - EXECUTING phase: Implement one concrete step from the TODO list
   - REVIEWING phase: Check what was done, update ROADMAP.md, assess if current approach is working

2. ROADMAP.md CREATION: If there is no ROADMAP.md file at the root of the repo, you must create it with these sections:
   * PROGRESS: Overall completion percentage, current phase, TODOs remaining, and active blockers count
   * OBJECTIVES: High-level goals from the user'\''s specifications
   * COMPLETED: Checked-off tasks with completion notes
   * IN_PROGRESS: Currently active task (should only be ONE item)
   * TODO: Remaining tasks with priority (P0/P1/P2), dependencies (format: [depends on: X, Y]), and estimated complexity
   * BLOCKED: Tasks that cannot proceed, with reasons and attempted solutions
   * DECISIONS: Key architectural/design decisions you took and rationale
   * LESSONS_LEARNED: Errors encountered, what didn'\''t work, and why
   * FUTURE_ENHANCEMENTS: Features/improvements not in original OBJECTIVES (for scope management)

3. ROADMAP.md PURPOSE: ROADMAP.md is used exclusively by you to coordinate across iterations. You must record your initiatives, design choices and errors into it. ROADMAP.md is how iterations coordinate, so err on caution - coordination with slow progress is preferable to losing track of the big picture.

4. MILITARY-STYLE COMMUNICATION: Keep ROADMAP entries BRIEF, SPECIFIC, ACTIONABLE
   - Format: "ACTION: what. REASON: why. STATUS: done/blocked/pending"
   - Example: "ADDED: logging to api.py. REASON: debug user auth errors. STATUS: done, tested"
   - No fluff, no verbose explanations - clarity over completeness

5. PLANNING BEFORE BUILDING: Do not start actual building until you are certain ROADMAP.md is ready.

6. ITERATION START REFLECTION: Start EVERY iteration by reading ROADMAP.md and writing a brief reflection:
   - Last completed: [what was done]
   - Next target: [what'\''s next]
   - Concerns: [any issues or NONE]
   - Phase: [PLANNING/EXECUTING/REVIEWING]

7. TASK VERIFICATION: Before executing any task, verify it still makes sense given current project state.

8. SCOPE MANAGEMENT: Never expand scope without explicit user request
   - If tempted to add features not in OBJECTIVES, document as "FUTURE_ENHANCEMENTS" in ROADMAP.md
   - Never add features beyond specifications
   - Simplest working solution first, optimization later
   - Focus on meeting OBJECTIVES, not on building the "best" solution

9. STAY ON TRACK: Don'\''t lose track of the user'\''s request - refer back to OBJECTIVES regularly.

10. PROGRESS TRACKING: At each iteration, update PROGRESS section with:
    - Completion percentage (be conservative: round down estimates)
    - Count of TODOs remaining
    - Count of active blockers
    - If progress stalls (same tasks in TODO for multiple iterations), switch to PLANNING to reassess approach

11. DEPENDENCY MANAGEMENT:
    - Mark dependencies explicitly in TODO items: "TODO: X [depends on: Y, Z]"
    - Never start a task until ALL dependencies are in COMPLETED
    - If multiple tasks are unblocked, choose lowest complexity first
    - Track dependency chains to avoid circular dependencies

12. STEP SIZE: Do ONE small, atomic change per iteration (e.g., edit one file, add one section, implement one small feature).
    - If a TODO seems too large, switch to PLANNING phase and break it into smaller TODOs first
    - Better too small than too large

13. UPDATE ROADMAP: Each step must include updating ROADMAP.md to reflect the change.

14. BLOCKER HANDLING: If you encounter a blocker or repeated errors (same issue twice), STOP executing and switch to PLANNING phase
    - Document all blockers explicitly in BLOCKED section with: what you tried, why it failed, alternative approaches to consider
    - Never retry the same failed solution without documenting why you think it will work this time

15. VERIFICATION AND ERRORS: After each change, verify it works as intended. If errors occur twice on the same goal, document in BLOCKED with what failed and alternative approaches, then ask user for guidance.

16. LEARNING FROM MISTAKES: If you realize a previous decision or implementation was wrong:
    - Document in DECISIONS section with "CORRECTION:" prefix
    - Update ROADMAP.md to reflect corrected approach
    - Move incorrectly completed items back to TODO or create new corrective tasks
    - Don'\''t hesitate to mark previously "completed" items as needing rework if issues are discovered
    - Learning from mistakes and adapting is more important than maintaining appearance of linear progress

17. FINISHED.md CREATION: Create FINISHED.md ONLY when ALL of these conditions are met:
    - All TODO items are checked and moved to COMPLETED
    - Run through ALL OBJECTIVES one-by-one and verify each is achieved
    - You have done a final REVIEWING phase to verify everything works
    - BLOCKED section is empty or all blockers are resolved/documented as acceptable limitations
    - You have test results or verification evidence for each objective

18. FINISHED.md CONTENT: In FINISHED.md, include:
    - Summary of what was built
    - Key decisions made (reference DECISIONS section)
    - Test results or verification evidence for each OBJECTIVE
    - Known limitations with severity ratings (CRITICAL/MINOR)
    - Suggestions for future improvements

19. AFTER COMPLETION: After creating FINISHED.md, ask the user what to do next.
</BUILDER_RULES>
'

# Function to show usage
show_help() {
    cat << EOF
Usage: aider_builder.sh -n_iter N -s SPECIFICATIONS [--extra_rules RULES_STRING] [AIDER_ARGS...]

Run aider in a loop with builder rules.

Required arguments:
  -n_iter N                    Number of iterations per batch (must be > 1)
  -s, --specifications SPEC    Specifications for what to build (passed as --message to aider)

Optional arguments:
  --extra_rules RULES      Additional rules to append to built-in builder rules
  -h, --help              Show this help message and exit
  -v, --version           Show version and exit
  
  AIDER_ARGS...           Additional arguments to pass to aider
                          Note: Do not use --message in AIDER_ARGS as it will be
                          automatically set from the --specifications argument

EOF
    exit 0
}

# Parse arguments
n_iter=""
specifications=""
extra_rules=""
aider_args=()

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -v|--version)
            echo "aider_builder.sh version $VERSION"
            exit 0
            ;;
        -n_iter)
            if [[ -z "$2" ]] || [[ ! "$2" =~ ^[0-9]+$ ]]; then
                echo "Error: -n_iter requires a number as argument"
                exit 1
            fi
            n_iter=$2
            shift 2
            ;;
        -s|--specifications)
            if [[ -z "$2" ]]; then
                echo "Error: -s/--specifications requires a string as argument"
                exit 1
            fi
            specifications=$2
            shift 2
            ;;
        --extra_rules)
            if [[ -z "$2" ]]; then
                echo "Error: --extra_rules requires a string as argument"
                exit 1
            fi
            extra_rules=$2
            shift 2
            ;;
        *)
            aider_args+=("$1")
            shift
            ;;
    esac
done

# Show help if no arguments provided
if [[ -z "$n_iter" ]] && [[ -z "$specifications" ]] && [[ ${#aider_args[@]} -eq 0 ]]; then
    show_help
fi

# Validate required arguments
if [[ -z "$n_iter" ]]; then
    echo "Error: -n_iter argument is required"
    echo "Use -h or --help for usage information"
    exit 1
fi

if [[ -z "$specifications" ]]; then
    echo "Error: -s/--specifications argument is required"
    echo "Use -h or --help for usage information"
    exit 1
fi

# Check that --message is not in aider_args
for arg in "${aider_args[@]}"; do
    if [[ "$arg" == "--message" || "$arg" == "-m" ]]; then
        echo "Error: --message/-m should not be provided in AIDER_ARGS"
        echo "Use -s/--specifications instead, which will be passed as --message to aider"
        exit 1
    fi
done

if [[ $n_iter -le 1 ]]; then
    echo "Error: -n_iter must be greater than 1"
    exit 1
fi

# Combine builder rules with extra rules if provided
combined_rules="$BUILDER_RULES"
if [[ -n "$extra_rules" ]]; then
    combined_rules="$combined_rules

<EXTRA_BUILDER_RULES>
$extra_rules
</EXTRA_BUILDER_RULES>
"
fi

# Create temporary file for rules
rules_tmp_file=$(mktemp)
trap "rm -f $rules_tmp_file" EXIT
echo "$combined_rules" > "$rules_tmp_file"

# Check if FINISHED.md already exists before starting
if [[ -f "FINISHED.md" ]]; then
    echo "Error: FINISHED.md already exists in the current directory"
    echo "This file indicates a previous build has finished."
    echo "Please remove or rename FINISHED.md before starting a new build session."
    exit 1
fi

counter=0
total_iterations=0

while true; do
    # Run loop n_iter times
    for ((i=1; i<=n_iter; i++)); do
        # Check if build is finished
        if [[ -f "FINISHED.md" ]]; then
            echo "\n###################"
            echo "# Build finished! FINISHED.md detected."
            echo "###################"
            echo "Completed $total_iterations total iterations."
            exit 0
        fi

        counter=$((counter + 1))
        total_iterations=$((total_iterations + 1))

        echo "\n###################"
        echo "# AiderBuilder iteration #$total_iterations ($(date))"
        echo "###################"

        aider --read "$rules_tmp_file" --message "Remember that you are in builder mode: $specifications" "${aider_args[@]}"
    done

    # Ask user to continue
    echo "\nCompleted $n_iter iterations (total: $total_iterations)"
    read "response?Continue for another $n_iter iterations? (y/N): "

    case $response in
        [Yy]* ) 
            echo "Continuing..."
            counter=0
            ;;
        * ) 
            echo "Stopping."
            exit 0
            ;;
    esac
done
