#!/usr/bin/zsh

VERSION="4.2.1"

# Built-in builder rules
BUILDER_RULES='If you see this text, you are expected to work in BUILDER mode. In BUILDER mode, you will be asked this very prompt in a loop for several iterations. This will allow you to tackle complex tasks like coding entire apps or writing LaTeX documents all from a single specification file.

<BUILDER_RULES>
## CORE RULES:

1. ROADMAP.md CREATION: If there is no ROADMAP.md file at the root of the repo, you must create it with these sections:
   * PROGRESS: Overall completion percentage, TODOs remaining, and active issues count
   * OBJECTIVES: High-level goals from the user'\''s specifications
   * COMPLETED: Checked-off tasks with completion notes
   * IN_PROGRESS: Currently active task (should only be ONE item)
   * TODO: Remaining tasks with priority (P0/P1/P2) and estimated complexity

   Extra sections you can create if relevant for the project:
   * BLOCKED: Tasks that cannot proceed, with reasons and attempted solutions
   * DECISIONS: Key design decisions you took and rationale
   * LESSONS_LEARNED: Errors encountered, what didn'\''t work, and why
   * FUTURE_ENHANCEMENTS: Features/improvements not in original OBJECTIVES (for scope management)

2. ROADMAP.md PURPOSE: ROADMAP.md is used exclusively by you to coordinate across iterations. You must record your initiatives, design choices and errors into it. ROADMAP.md is how iterations coordinate, so err on caution - coordination with slow progress is preferable to losing track of the big picture. Do not start actual building until you are certain ROADMAP.md is ready.

3. MILITARY-STYLE COMMUNICATION: Keep ROADMAP entries BRIEF, SPECIFIC, ACTIONABLE
   - Format: "ACTION: what. REASON: why. STATUS: done/blocked/pending"
   - Example: "ADDED: logging to api.py. REASON: debug user auth errors. STATUS: done, tested"
   - No fluff, no verbose explanations - clarity over completeness

4. ITERATION START REFLECTION: Start EVERY iteration by reading ROADMAP.md and writing a brief reflection:
   - Last completed: [what was done]
   - Next target: [what'\''s next]
   - Concerns: [any issues or NONE]

5. FOCUS: Before executing any task, verify it still makes sense given current project state. Don'\''t lose track of the user'\''s request - refer back to OBJECTIVES regularly.

6. SCOPE MANAGEMENT: Never expand scope without explicit user request
   - If tempted to add tasks not in OBJECTIVES, document as "FUTURE_ENHANCEMENTS" in ROADMAP.md
   - Never add features beyond specifications without approval.
   - Working solution first, complex optimization later
   - Focus on meeting OBJECTIVES, not on building the "best" solution

7. STEP SIZE: Do ONE small, atomic change per iteration (e.g., edit one file, add one section, implement one small thing).
    - If a TODO seems too large, break it into smaller TODOs first
    - Better too small than too large

8. UPDATE ROADMAP: Each step must include updating ROADMAP.md to reflect the change.

9. ADAPTIVE LEARNING: When errors occur or decisions prove wrong:
    - Document in ROADMAP.md what failed and why
    - If same issue appears twice, STOP and document alternatives in BLOCKED
    - Don'\''t hesitate to move "completed" items back to TODO if issues are discovered
    - Correction is progress, not failure

10. FINISHED.md CREATION: Create FINISHED.md ONLY when ALL of these conditions are met:
    - All TODO items are checked and moved to COMPLETED
    - Run through ALL OBJECTIVES one-by-one and verify each is achieved
    - You have verified everything works
    - BLOCKED section is empty or all issues are resolved/documented as acceptable limitations
    - You have test results or verification evidence for each objective

11. FINISHED.md CONTENT: In FINISHED.md, include:
    - Summary of what was built
    - Key decisions made (reference DECISIONS section)
    - Test results or verification evidence for each OBJECTIVE
    - Known limitations with severity ratings (CRITICAL/MINOR)
    - Suggestions for future improvements
    After creating FINISHED.md, ask the user what to do next.

</BUILDER_RULES>
'

# Function to show usage
show_help() {
    cat << EOF
Usage: aider_builder.sh -n_iter N -s SPECIFICATIONS [AIDER_ARGS...]

Run aider in a loop with builder rules.

Required arguments:
  -n_iter N                    Number of iterations per batch (must be > 1)
  -s, --specifications SPEC    Specifications for what to build (passed as --message to aider)

Optional arguments:
  -h, --help              Show this help message and exit
  -v, --version           Show version and exit
  
  AIDER_ARGS...           Additional arguments to pass to aider
                          Note: Do not use --message in AIDER_ARGS as it will be
                          automatically set from the --specifications argument

EOF
    exit 0
}

# Parse arguments
n_iter=""
specifications=""
aider_args=()

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -v|--version)
            echo "aider_builder.sh version $VERSION"
            exit 0
            ;;
        -n_iter)
            if [[ -z "$2" ]] || [[ ! "$2" =~ ^[0-9]+$ ]]; then
                echo "Error: -n_iter requires a number as argument"
                exit 1
            fi
            n_iter=$2
            shift 2
            ;;
        -s|--specifications)
            if [[ -z "$2" ]]; then
                echo "Error: -s/--specifications requires a string as argument."
                exit 1
            fi
            specifications=$2
            shift 2
            ;;
        *)
            aider_args+=("$1")
            shift
            ;;
    esac
done

# Show help if no arguments provided
if [[ -z "$n_iter" ]] && [[ -z "$specifications" ]] && [[ ${#aider_args[@]} -eq 0 ]]; then
    show_help
fi

# Validate required arguments
if [[ -z "$n_iter" ]]; then
    echo "Error: -n_iter argument is required"
    echo "Use -h or --help for usage information"
    exit 1
fi

if [[ -z "$specifications" ]]; then
    echo "Error: -s/--specifications argument is required"
    echo "Use -h or --help for usage information"
    exit 1
fi

# Check that --message is not in aider_args
for arg in "${aider_args[@]}"; do
    if [[ "$arg" == "--message" || "$arg" == "-m" ]]; then
        echo "Error: --message/-m should not be provided in AIDER_ARGS"
        echo "Use -s/--specifications instead, which will be passed as --message to aider"
        exit 1
    fi
done

if [[ $n_iter -le 1 ]]; then
    echo "Error: -n_iter must be greater than 1"
    exit 1
fi

# Create temporary file for rules
rules_tmp_file=$(mktemp)
trap "rm -f $rules_tmp_file" EXIT
echo "$BUILDER_RULES" > "$rules_tmp_file"

# Check if FINISHED.md already exists before starting
if [[ -f "FINISHED.md" ]]; then
    echo "Error: FINISHED.md already exists in the current directory"
    echo "This file indicates a previous build has finished."
    echo "Please remove or rename FINISHED.md before starting a new build session."
    exit 1
fi

counter=0
total_iterations=0

while true; do
    # Run loop n_iter times
    for ((i=1; i<=n_iter; i++)); do
        # Check if build is finished
        if [[ -f "FINISHED.md" ]]; then
            echo "\n###################"
            echo "# Build finished! FINISHED.md detected."
            echo "###################"
            echo "Completed $total_iterations total iterations."
            exit 0
        fi

        counter=$((counter + 1))
        total_iterations=$((total_iterations + 1))

        echo "\n###################"
        echo "# AiderBuilder iteration #$total_iterations ($(date))"
        echo "###################"

        aider --read "$rules_tmp_file" --message "You are in BUILDER mode.

Here are the user specifications:
<SPECIFICATIONS>
$specifications
</SPECIFICATIONS>
" "${aider_args[@]}"
    done

    # Ask user to continue
    echo "\nCompleted $n_iter iterations (total: $total_iterations)"
    read "response?Continue for another $n_iter iterations? (y/N): "

    case $response in
        [Yy]* ) 
            echo "Continuing..."
            counter=0
            ;;
        * ) 
            echo "Stopping."
            exit 0
            ;;
    esac
done
